library(dplyr)
library(caret)
library(randomForest)
library(library(e1071)   # Para SVM
library(rpart)  # Para DT
library(rpart.plot) # Para DT
library(rattle) # Para DT
        
        
# Cargamos los encabezados del dataframe desde el archivo column_names.txt
        
encabezados <- readLines("column_names.txt")
        
# Cargamos los datos desde el archivo gene_expression.csv
        
datos <- read.csv("gene_expression.csv", header = FALSE, sep = ";")
        
# Asignamos los encabezados al dataframe
        
colnames(datos) <- encabezados
        
# Guardamos el dataframe con encabezados en un nuevo archivo CSV
        
write.csv(datos, "datos_combinados.csv", row.names = FALSE)
        data <- read.csv("datos_combinados.csv")
        
# Cargamos las etiquetas de los datos (no tienen encabezados, por lo que se lo añadimos)
        
encabezado_clases <- c("Sample", "Class")
clases <- read.csv('classes.csv', header = FALSE, sep = ";")
colnames(clases) <- encabezado_clases
        
#Al observar los datos vemos que algunos genes tienen 0 expresión en todas las muestras, por lo que eliminamos las columnas con valor 0 que no aportan información
        
sumas <- colSums(data) # sumo los datos por columnas
columnascero <- names(sumas[sumas==0]) # veo cuantas sumas son == 0
data2 <- data[, !names(data) %in% columnascero] # reemplazo el dataset df sin esas columnas
        
#Incluimos la columna de la clase de cada muestra y escalamos los datos
df <- cbind(clases["Class"],scale(data2))
        
#Asignamos el ID de cada muestra al nombre de cada fila
rownames(df) <- clases$Sample


#Reducimos la dimensionalidad mediante el método MDS
#Primero calculamos la matriz de las distancias euclidias
distancias<- dist(df, method = "euclidean")

#Usamos la función mcdscale para realizar el MDS
mdsresults<-cmdscale(distancias, eig = TRUE, k=2)

#Calculamos la varianza explicada
varianza<-mdsresults$eig/sum(mdsresults$eig)*100

#Pasamos a df los datos 
mds.df<-data.frame(mdsresults$points)
colnames(mds.df) <- c("Dim1", "Dim2")

#Graficamos    
mds.df$Class<-clases$Class

library(ggplot2)
ggplot(mds.df, aes(x=Dim1, y=Dim2, color= Class))+
  geom_point(size=2)+
  scale_color_manual(values = c("red", "green", "yellow", "blue", "purple"))+
  labs(title = "MDS", x = "D1", y = "D2")
theme_minimal()

#Realizamos la técnica t-SNE de reducción de dimensionalidad.
library(Rtsne)
#En primer lugar creamos un df sólo con datos numéricos

df.numerico <- df[, sapply(df, is.numeric)]

#Ahora hay que crear una matriz con los datos

matriz<-as.matrix(df.numerico)

#Hay que usar una semilla de aleatorización para que sea reproducible
set.seed(142)

#Añadimos el código
tsne<-Rtsne(X=df.numerico)
tsne_result <- Rtsne(matriz, dims = 2, perplexity = 20, verbose = TRUE, max_iter = 500)

#Creamos un data frame con los resultados anteriores

tsne_df<-as.data.frame(tsne_result$Y)
colnames(tsne_df)<-c("Dim1", "Dim2")
tsne_df$Class<-df$Class

#Graficamos

ggplot(tsne_df, aes(x=Dim1, y=Dim2, colour = Class))+
  geom_point(size=1)+
  scale_color_manual(values = c("red", "green", "yellow", "blue", "purple"))+
  labs(title ="t-SNE", x="Dimensión 1", y="Dimensión 2")+
  theme_minimal()
